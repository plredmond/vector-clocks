#lang ivy1.8

include order
include collections

# This is `keyval` copied from the ivy1.8 stdlib, but modified for our purpose
# to use as the backing for a vector clock.
module mapping(index, key, data) = {

    type this
    alias t=this 

    function end(A:t) : index.t
    relation key_at(A:t, I:index.t, X:key)
    function value_at(A:t, I:index.t) : data
    
    action empty returns (s:t)
    action get_key(s:t, i:index.t) returns (k:key)
    action get_value(s:t, i:index.t) returns (d:data)
    action find(s:t, k:key) returns (i:index.t)
    action get(s:t, k:key, d:data) returns (d:data)
    action set(s:t, k:key, d:data) returns (s:t)
    
    object spec = {

        property key_at(A, I, X) -> 0 <= I & I < end(A)
        property key_at(A, I, X) & key_at(A, I, Y) -> X = Y
        property 0 <= end(A) 

        after empty {
            assert s.end = 0 & ~key_at(s, I, X);
        }

        before get_key {
            assert 0 <= i & i < s.end
        }
        after get_key {
            assert key_at(s, i, k)
        }

        before get_value {
            assert 0 <= i & i < s.end
        }
        after get_value {
            assert value_at(s, i) = d
        }

        after find {
            assert s.key_at(I, k) -> s.key_at(i, k);
            assert (forall I. ~s.key_at(I, k)) <-> s.end = i;
        }

        before get {
            # FIXME need a representation invariant that the same key isn't at two indexes
            assert [uniqueIx4Key] s.key_at(I, X) & s.key_at(J, X) -> I = J;
        }
        after get {
            assert s.key_at(I, k) -> s.value_at(I) = d; # Requires uniqueIx4Key
        }

        before set {
            # FIXME need a representation invariant that the same key isn't at two indexes
            assert [uniqueIx4Key] s.key_at(I, X) & s.key_at(J, X) -> I = J;
        }
        after set {
            assert [unchangedIxKeys]                       k ~= X -> key_at(s, I, X) = key_at(old s, I, X);
            assert [unchangedIxVals] key_at(old s, I, X) & k ~= X -> value_at(s, I) = value_at(old s, I);
            assert [updatedExisting] key_at(old s, I, k) -> key_at(s, I, k) & value_at(s, I) = d; # Requires uniqueIx4Key
            assert [appendedNewKey] (forall I. ~key_at(old s, I, k)) -> key_at(s, end(old s), k) & value_at(s, end(old s)) = d;
        }
    }

    object impl = {

        type pair = struct {
            p_key : key,
            p_value : data
        }

        instance arr : array(index.t, pair)

        destructor repr(X:t) : arr.t

        definition end(A:t) = repr(A).end
        definition value_at(A, I) = repr(A).value(I).p_value
        definition key_at(A, I, X) = (0 <= I & I < end(A) & repr(A).value(I).p_key = X)
        
        implement empty {
            repr(s) := arr.empty
        }

        implement get_key {
            k := repr(s).get(i).p_key
        }

        implement get_value {
            d := repr(s).get(i).p_value
        }

        implement find {
            i := 0;
            while i < s.end & ~s.key_at(i, k)
            invariant ~s.key_at(i, k) & I < i -> ~s.key_at(I, k)
            invariant i <= s.end
            {
                i := i.next;
            }
        }

        implement get {
            var i := s.find(k);
            if i < s.end {
                d := repr(s).value(i).p_value;
            }
        }

        implement set {
            var p : pair;
            p.p_key := k;
            p.p_value := d;

            var i := s.find(k);
            if i < s.end {
                repr(s) := repr(s).set(i, p);
            } else {
                repr(s) := repr(s).append(p)
            }
        }
    }
    isolate iso = this with index
    attribute test=impl
}

instance x : unbounded_sequence
instance kv : mapping(x, x, x)
export kv.empty
export kv.get_key
export kv.get_value
export kv.find
export kv.get
export kv.set
