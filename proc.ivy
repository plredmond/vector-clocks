#lang ivy1.8

type node
type payload
type event_type = {init_ev, send_ev, deliver_ev}
type event = struct {
    ev_node: node,
    ev_type: event_type,
    ev_mesg: payload
}

# GL: start with a representation of global execution; representing whole
# system's behavior
object causal_delivery_service = {

    # called by user/app to pass information down to our layer
    action send(loc:node, mesg:payload)

    # called by us to pass information up to user/app layer
    action deliver(loc:node, mesg:payload)

    # PR: what can we say that's interesting now?
    # GL: service behaves like a set of messages; if you send something,
    # it's in the set, and somebdy can deliver it

    # GL: after sending a thing, it is added to the set
    relation sent(M:payload)
    relation localEvents(L:node, E:event)
    relation hb(E1:event, E2:event)

    specification {
        after send {
            var s : event;
            ev_node(s) := loc;
            ev_type(s) := send_ev;
            ev_mesg(s) := mesg;

            # GL: should we restrict sending twice `assert ~sent(mesg);`?
            # PR: maybe treat that as idempotent?

            sent(mesg) := true;
            localEvents(loc, s) := true;
            # TODO here: update hb

            #hb(M1, mesg) := true;
            # PR: why not `assert sent(mesg);`?
            # GL: better perhaps to use the imperative
            # specification here because it also implies that what
            # was already there is preserved
        }
        before deliver {
            assert sent(mesg);
            # TODO lower level: deliverableAt(mesg, loc);
        }
        after deliver {
            var d : event;
            ev_node(d) := loc;
            ev_type(d) := deliver_ev;
            ev_mesg(d) := mesg;

            var s : event;
            #ev_node(s) := loc; # need to obtain the sender somehow
            ev_type(s) := send_ev;
            ev_mesg(s) := mesg;

            # TODO here: update localEvents
            # TODO here: update hb

            # TODO lower level: update local clock

            assert old sent(M) <-> sent(M);
        }
    }

    # we won't be able to do transitive closure
    #
    # (overapproximation) e.g. create a relation that says some things are
    # causally related when they aren't; won't cause a safety violation, but
    # will cause liveness issue -- the implementation will deliver messages
    # that this cannot, so perhaps we need an underapproximation
    #
    # (underapproximation) e.g. ?

    #implementation {
    #    implement send {
    #    }
    #    #implement deliver { } # (should be an error)
    #}
}

export causal_delivery_service.send # anybody can call send
import causal_delivery_service.deliver # user provides us a callback
