#lang ivy1.7

include order
include collections

module vector_clock(pid_t : iterable) = {
    type this

    # representation
    instance clock_t : unbounded_sequence
    function clock(P:pid_t) : clock_t

    # interface
    action empty returns (x:this)
    action step(x:this, pid:pid_t) returns (x:this)
    action merge(x:this, y:this) returns (x:this)
    action leq(x:this, y:this) returns (b:bool)
    action lt(x:this, y:this) returns (b:bool)

    invariant [sizeIsNat] 0 <= pid_t.size

    specification {
        # QQQ Can we use "after init" instead?
        after empty {
            #TODO assert clock(P) = 0
        }
        after step {
            #TODO assert clock(P) = clock(old P)
        }
        # TODO merge
        # TODO leq
        # TODO lt
    }

    implementation {
        instance array_t : array(pid_t, clock_t)
        individual arr : array_t

        # define representation in terms of implementation
        definition clock(P:pid_t) = arr.value(P)

        # QQQ what relates arr assigned here to x defined in the signature??
        implement empty {
            arr := array_t.create(pid_t.size, 0)
        }
        implement step {
            # TODO
        }
        # TODO merge
        # TODO leq
        # TODO lt
    }

    isolate iso = this
}

instance pid_tx : iterable
instance mod_tx : vector_clock(pid_tx)
#export mod_tx.empty
#export mod_tx.step
#export mod_tx.merge
#export mod_tx.leq
#export mod_tx.lt
