#lang ivy1.7

include order

instance pid_t : iterable
instance clock_t : unbounded_sequence

module vc_mod = {
    type this

    # abstract representation
    function clock(X:this, P:pid_t) : clock_t

    # interface
    action step(x:this, p:pid_t) returns (x:this)
    action merge(x:this, y:this) returns (x:this)
    action leq(x:this, y:this) returns (b:bool)
    action lt(x:this, y:this) returns (b:bool)
    action get(x:this, p:pid_t) returns (c:clock_t)

    after init {
        clock(X, P) := 0;
        assert clock(X, P) = 0;
        #assert false;
    }

    specification {
        after step {
            #assert clock_t.succ(old x.clock(p), x.clock(p)); #FIXME
            assert P ~= p -> old x.clock(P) = x.clock(P);
            #assert false;
        }
        after merge {
            assert old x.clock(P) <= x.clock(P);
            assert     y.clock(P) <= x.clock(P);
            #assert false;
        }
        after leq {
            assert [unchanged] old x.clock(P) = x.clock(P);
            assert b = forall P. x.clock(P) <= y.clock(P);
            #assert false;
        }
        after get {
            assert x.clock(P) = old x.clock(P);
            #assert false;
        }
    }

    implementation {
        implement step {
            x.clock(p) := x.clock(p).next;
            #assert false;
        }
        implement merge {
            x.clock(P) := x.clock(P) if y.clock(P) < x.clock(P) else y.clock(P);
            #assert false;
        }
        implement leq {
            b := forall P. x.clock(P) <= y.clock(P)
            #assert false;
        }
        implement get {
            c := x.clock(p);
            #assert false;
        }
    }

    # TODO: how to *also* provide a cpp implementation?
}

instance vc_t : vc_mod
export vc_t.step
export vc_t.merge
export vc_t.leq
export vc_t.lt
export vc_t.get
# check exported actions
#   ivy_check trace=true vc.ivy

extract impl = this, pid_t, clock_t, vc_t
# extract to cpp code
#   ivy_to_cpp isolate=impl target=class vc.ivy
# extract to repl
#   ivyc isolate=impl vc.ivy
#   ./vc 3
#   > vc_t.step(myvc, 0)

# TODO: after this is complete, try using simple-udp in the networking stdlib;
# also look at network_shim, as used by the tendermint example; message will be
# struct w/sender and vc
