#lang ivy1.8

include order

instance pid_t : iterable
instance clock_t : unbounded_sequence

# defining a `type this = struct { â€¦ }` should be equivalent to
# several `destructor <fieldname>(X:this) : <fieldtype>` according to
# the datatype tutorial

module vc_mod = {
    type this

    # abstract representation
    function clock(X:this, P:pid_t) : clock_t
    # FIXME: use a destructor whose type is keyval(pid_t, clock_t)

    relation eq(X:this, Y:this)
    relation leq(X:this, Y:this)
    relation lt(X:this, Y:this)
    definition eq(X:this, Y:this) = forall P. X.clock(P) = Y.clock(P)
    definition leq(X:this, Y:this) = forall P. X.clock(P) <= Y.clock(P)
    definition lt(X:this, Y:this) = leq(X, Y) & ~eq(X, Y)

    # interface
    action step(x:this, p:pid_t) returns (x:this)
    action merge(x:this, y:this) returns (x:this)
    action equal(x:this, y:this) returns (b:bool)
    action lessEqual(x:this, y:this) returns (b:bool)
    action lessThan(x:this, y:this) returns (b:bool)
    action get(x:this, p:pid_t) returns (c:clock_t)

    after init {
        clock(X, P) := 0;
        assert clock(X, P) = 0;
    }

    specification {
        after step {
            #assert [incrementedIx] clock_t.succ(old x.clock(p), x.clock(p)); #FIXME
            assert [unchangedIxs] P ~= p -> old x.clock(P) = x.clock(P);
        }
        after merge {
            assert [resultGeqOld] leq(old x, x);
            assert [resultGeqOther] leq(y, x);
        }
        after equal {
            assert [unchanged] eq(old x, x);
            assert [result] b = eq(x, y);
        }
        after lessEqual {
            assert [unchanged] eq(old x, x);
            assert [result] b = leq(x, y);
        }
        after lessThan {
            assert [unchanged] eq(old x, x);
            assert [result] b = lt(x, y);
        }
        after get {
            assert [unchanged] eq(old x, x);
            assert [result] c = x.clock(p);
        }
    }

    implementation {
        implement step {
            x.clock(p) := x.clock(p).next;
        }
        implement merge {
            x.clock(P) := x.clock(P) if y.clock(P) < x.clock(P) else y.clock(P);
        }
        implement equal {
            b := eq(x, y);
        }
        implement lessEqual {
            b := leq(x, y);
        }
        implement lessThan {
            b := lt(x, y);
        }
        implement get {
            c := x.clock(p);
        }
    }

    # TODO: how to *also* provide a cpp implementation?
}

instance vc_t : vc_mod
export vc_t.step
export vc_t.merge
export vc_t.equal
export vc_t.lessEqual
export vc_t.lessThan
export vc_t.get
# check exported actions
#   ivy_check trace=true vc.ivy

extract impl = this, pid_t, clock_t, vc_t
# extract to cpp code
#   ivy_to_cpp isolate=impl target=class vc.ivy
# extract to repl
#   ivyc isolate=impl vc.ivy
#   ./vc 3
#   > vc_t.step(myvc, 0)

# TODO: after this is complete, try using simple-udp in the networking stdlib;
# also look at network_shim, as used by the tendermint example; message will be
# struct w/sender and vc
